<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed Prime Computation - Worker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* ... CSS styles remain the same ... */
    </style>
</head>
<body>
    <h1 class="header">Distributed Prime Computation - Worker</h1>

    <div class="container flex flex-col items-center mt-8">
        <h2 class="section-title w-full text-center">Worker Status</h2>
        <div id="worker-id-display" class="text-lg font-bold mt-2">Worker ID: <span id="my-worker-id">N/A</span></div>
        <div id="status" class="status-box mt-4 w-full">Connecting to coordinator...</div>
        <div class="mt-4 w-full text-center">
            <p class="font-bold">Tasks Completed by me: <span id="my-tasks-completed">0</span></p>
            <p class="font-bold">Primes Found by me: <span id="my-primes-found">0</span></p>
        </div>
    </div>

<script type="module">
    import { getClientInfo } from './stats.js'; // Import our new stats helper

    const statusDiv = document.getElementById('status');
    const myWorkerIdSpan = document.getElementById('my-worker-id');
    const myTasksCompletedSpan = document.getElementById('my-tasks-completed');
    const myPrimesFoundSpan = document.getElementById('my-primes-found');

    let myWorkerId = null;
    let myTasksCompleted = 0;
    let myPrimesFound = 0n; // Using BigInt for large numbers
    let workerSocket;

    // Dynamically set the WebSocket URL based on the page's location
    const COORDINATOR_WS_URL_WORKER = `ws://${window.location.host}`; 

    // Corrected the worker script name here
    const computationWorker = new Worker('./worker_bootstrap.js', { type: 'module' });

    // Generates a unique ID for each worker instance.
    function generateWorkerId() {
        return 'worker-' + Date.now().toString(36) + Math.random().toString(36).substring(2);
    }

    // Handles messages received from the computation worker thread.
    computationWorker.onmessage = (event) => {
        const data = event.data;
        switch (data.type) {
            case 'status':
                // Update the status display with messages from the worker.
                statusDiv.textContent = data.message;
                break;
            case 'stillWorking':
                // Periodically informs the server that the worker is still processing a task.
                workerSocket.send(JSON.stringify({ type: 'stillWorking', workerId: myWorkerId, taskId: data.taskId, memory: data.memory }));
                break;
            case 'result':
                // When a task is complete, update the UI and send the result to the server.
                const primeCountBigInt = BigInt(data.count);
                myTasksCompleted++;
                myPrimesFound += primeCountBigInt;
                myTasksCompletedSpan.textContent = myTasksCompleted;
                myPrimesFoundSpan.textContent = myPrimesFound.toLocaleString();
                statusDiv.textContent = '✅ Task complete. Awaiting next task.';
                workerSocket.send(JSON.stringify({ type: 'result', workerId: myWorkerId, taskId: data.taskId, count: data.count.toString() })); // Ensure count is a string for JSON
                break;
            case 'error':
                // If the worker encounters an error, report it to the server.
                statusDiv.textContent = `❌ Error on task #${data.taskId}. Reporting to server.`;
                workerSocket.send(JSON.stringify({ type: 'error', workerId: myWorkerId, taskId: data.taskId, message: data.message }));
                break;
        }
    };
    
    // Establishes and manages the WebSocket connection to the coordinator server.
    function connectWorkerSocket() {
        // Generate a unique ID for this worker if it doesn't have one.
        if (myWorkerId === null) {
            myWorkerId = generateWorkerId();
            myWorkerIdSpan.textContent = myWorkerId; // Display the full ID
        }

        statusDiv.textContent = 'Connecting to coordinator...';
        workerSocket = new WebSocket(COORDINATOR_WS_URL_WORKER); 

        // When the connection is established, register the worker with the server.
        workerSocket.onopen = () => {
            statusDiv.textContent = '✅ Connected. Awaiting tasks.';
            const clientInfo = getClientInfo(); // Get browser and OS info.
            workerSocket.send(JSON.stringify({ 
                type: 'registerWorker', 
                workerId: myWorkerId, 
                browserInfo: clientInfo.browserInfo,
                cpuCores: clientInfo.cpuCores
            }));
        };

        // Handles incoming messages from the server (i.e., new tasks).
        workerSocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'task') {
                // Pass the new task to the computation worker.
                computationWorker.postMessage({ task: data.task });
            }
        };

        // If the connection is closed, attempt to reconnect after a delay.
        workerSocket.onclose = () => {
            statusDiv.textContent = '❌ Disconnected. Reconnecting in 5 seconds...';
            setTimeout(connectWorkerSocket, 5000);
        };

        // Handles WebSocket connection errors.
        workerSocket.onerror = (error) => {
            console.error('Worker WebSocket Error:', error);
            workerSocket.close(); // Triggers the onclose event for reconnection.
        };
    }

    // Initiate the connection when the page loads.
    connectWorkerSocket();
</script>

</body>
</html>